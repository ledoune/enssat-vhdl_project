-- Structurel du projet son sur carte DEO NANO 
-- contenant les deux interfaces avec les convertisseurs
-- reliées par un simple registre

library IEEE;
use IEEE.STD_LOGIC_1164.all;
use IEEE.numeric_std.all;

library work;
use work.son.all;

ENTITY de0nanoson IS
	PORT (
		clk       :  IN      STD_LOGIC;
		ADC_CONVST        : out std_logic ;  --impulsion = start la conversion
		ADC_SCK           : out std_logic ;  --data clock SCK SPI
		ADC_SDI           : out std_logic ;  --data input SDI SPI(configuration de l ADC, par exemple channel à mesurer)
		ADC_SDO	         : in std_logic  ;  --data output SDO SPI (envoie la valeur numérique bit par bit)
		ECHANTE           : out std_logic ;  --impulsion = start la conversion entrée pour observation 
		ECHANTS           : out std_logic ;  --impulsion = start la conversion en sortie pour observation 
		measure_done      : out std_logic ;  --indique si la conversion est finie
		start_trait       : out std_logic ;  --pour observation
		fin_trait         : out std_logic ;  --pour observation
		BP0               :  IN      STD_LOGIC;   --active low reset
		SCL               : INOUT STD_LOGIC;  -- bus I2C vers CNA
		SDA               : INOUT  STD_LOGIC; -- bus I2C vers CNA
		SCLcopie : INOUT STD_LOGIC;          -- pour observation
		SDAcopie : INOUT STD_LOGIC           -- pour observation
		    
  );
END de0nanoson;

ARCHITECTURE structurelle OF de0nanoson IS 

Component ADC2 IS       
  PORT( 
    	 rstb              : in std_logic ; -- reset asynchrone général
		 clk              : in std_logic ;
	    measure_ch       : in std_logic_vector (2 downto 0) ;  --canal à mesurer (entre 0 et 7)
	    measure_done     : out std_logic ;  --indique si la conversion est finie
	    measure_dataread : out std_logic_vector (NbitCAN-1 downto 0) ; --la valeur numérique du signal analogique (sur 12 bits)
       ADC_CONVST       : out std_logic ;  --impulsion = start la conversion
	    ADC_SCK          : out std_logic ;  --data clock du bus SPI
       ADC_SDI          : out std_logic ;  --data input (configuration de l ADC, par exemple channel à mesurer)
		 ADC_SDO	         : in std_logic  ;  --data output (envoie la valeur numérique bit par bit)
		 ECHANT           : out std_logic   --impulsion = identique a ADC_CONVST pour observation sur le connecteur GPIO  
		 ); 
 END component ADC2;

COMPONENT DAC IS
  GENERIC(
    input_clk :  INTEGER := 50_000_000; --input clock speed from user logic in Hz
    bus_clk   :  INTEGER := 400_000);   --speed the i2c bus (scl) will run at in Hz
  PORT(
    Tnum         :  IN      STD_LOGIC_VECTOR ( NbitCNA-1 downto 0); -- entrée à convertir
    clk       :  IN      STD_LOGIC;                    --system clock
    reset_n   :  IN      STD_LOGIC;                    --active low reset
    ena       :  IN      STD_LOGIC;                    --latch in command
    sda       :  INOUT   STD_LOGIC;                    --serial data output of i2c bus
    scl       :  INOUT   STD_LOGIC);                   --serial clock output of i2c bus
END COMPONENT DAC;

SIGNAL smeasure_done    :  std_logic  ; 
SIGNAL sdataADC    :  Std_Logic_Vector(NbitCAN-1 downto 0); -- signal d'entrée converti
SIGNAL sdataDAC    :  Std_Logic_Vector ( NbitCNA-1 downto 0); -- entrée à convertir

 
BEGIN

instance_ADC2 : ADC2 port map (BP0,clk,"000",smeasure_done,sdataADC,ADC_CONVST,ADC_SCK,ADC_SDI,ADC_SDO,ECHANTE);

-- simple registre de connexion
process (clk, BP0)
begin
   if (BP0='0') then sdataDAC <= (others => '0');
	   elsif ( rising_edge(clk) ) then
		  if (smeasure_done='1') then 
	        sdataDAC <= sdataADC;
		  end if;
  end if;

end process;


instance_DAC : DAC port map (sdataDAC,clk,BP0,'1',SDA,SCL);

-- positionnement des signaux soit pour observation, soit non utilisés pour l'instant
measure_done  <= smeasure_done;
SCLcopie <= SCL;
SDAcopie <= SDA;
ECHANTS <= smeasure_done;
start_trait <= '1';
fin_trait <= '1';

END structurelle ;

  
